{
  "name": "case-finder_base",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "main_pair_key"
            },
            {
              "name": "pairs_key"
            }
          ]
        }
      },
      "id": "be4d511c-35f8-4a67-8b82-47e70214216b",
      "typeVersion": 1.1,
      "name": "When Executed by Another Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        -288,
        208
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- $1::bigint = main_pair_key\n-- $2::text   = pairs_key (лучше передавать как JSON.stringify([...]) либо любую строку с цифрами)\n\nWITH keyset AS (\n  SELECT $1::bigint AS pair_key, TRUE AS is_ref\n  UNION ALL\n  SELECT (m[1])::bigint AS pair_key, FALSE AS is_ref\n  FROM regexp_matches($2::text, '(\\d+)', 'g') AS m\n),\nkeys_dedup AS (\n  SELECT pair_key, bool_or(is_ref) AS is_ref\n  FROM keyset\n  GROUP BY pair_key\n)\nSELECT\n  d.*,\n  k.is_ref\nFROM \"difference\" d\nJOIN keys_dedup k\n  ON d.pair_key::bigint = k.pair_key      -- если d.pair_key уже bigint, убери ::bigint\nORDER BY\n  k.is_ref DESC,\n  d.pair_key,\n  \"delta t\" DESC;                   -- <-- если колонка называется иначе, см. ниже",
        "options": {
          "queryReplacement": "=$1 = {{ $json.main_pair_key }}\n$2 = {{ $json.pairs_key }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -64,
        192
      ],
      "id": "22d6831f-3e0c-4a47-8fb2-525b449522cf",
      "name": "Execute a SQL query1",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "BS3jzABtgD6WMJ0p",
          "name": "Postgres account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node\n// Adds trace_steps / trace_points for each candidate + ref\n// + covariance similarity + delta-t similarity\n// + mass delta (ref vs candidate)\n// + NEW: pair_a / pair_b names per series\n\nconst MAX_STEPS = 20;\nconst TRACE_MAX_STEPS = 12;\nconst INCLUDE_REF_TRACE = true;\n\nconst SECTION_WEIGHTS = { pc: 0.50, miss: 0.30, relSpeed: 0.20 };\nconst SECTION_WEIGHTS_V2 = { pc: 0.40, miss: 0.25, relSpeed: 0.15, cov: 0.15, dt: 0.05 };\n\nconst DT_HARD_DAYS = 1.2;\n\nconst TREND_LEVEL_BLEND = { trend: 0.70, level: 0.30 };\nconst SHAPE_MAG_DIR = { wShape: 0.50, wMag: 0.30, wDir: 0.20 };\nconst SHAPE_MAG = { wShape: 0.55, wMag: 0.45 };\n\nconst COV_COMPONENT_WEIGHTS = { rss: 0.40, max: 0.40, trace: 0.20 };\n\nfunction parseMaybeJson(x) {\n  if (x === null || x === undefined) return null;\n  if (typeof x === 'object') return x;\n  if (typeof x !== 'string') return null;\n  const s = x.trim();\n  if (!s) return null;\n  try { return JSON.parse(s); } catch { return null; }\n}\nfunction toNum(x) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n}\nfunction log10Safe(x) {\n  const n = toNum(x);\n  if (n === null || n <= 0) return null;\n  return Math.log10(n);\n}\nfunction log1pSafe(x) {\n  const n = toNum(x);\n  if (n === null || n < 0) return null;\n  return Math.log1p(n);\n}\nfunction median(arr) {\n  const a = arr.filter(Number.isFinite).sort((x, y) => x - y);\n  if (!a.length) return null;\n  const m = Math.floor(a.length / 2);\n  return a.length % 2 ? a[m] : 0.5 * (a[m - 1] + a[m]);\n}\nfunction mae(x, y) {\n  const n = Math.min(x.length, y.length);\n  let s = 0, k = 0;\n  for (let i = 0; i < n; i++) {\n    const xi = x[i], yi = y[i];\n    if (!Number.isFinite(xi) || !Number.isFinite(yi)) continue;\n    s += Math.abs(xi - yi);\n    k++;\n  }\n  return k ? s / k : null;\n}\nfunction pearsonCorr(x, y) {\n  const n = Math.min(x.length, y.length);\n  let sx = 0, sy = 0, sxx = 0, syy = 0, sxy = 0, k = 0;\n  for (let i = 0; i < n; i++) {\n    const xi = x[i], yi = y[i];\n    if (!Number.isFinite(xi) || !Number.isFinite(yi)) continue;\n    sx += xi; sy += yi;\n    sxx += xi * xi; syy += yi * yi; sxy += xi * yi;\n    k++;\n  }\n  if (k < 3) return null;\n  const cov = sxy - (sx * sy) / k;\n  const vx  = sxx - (sx * sx) / k;\n  const vy  = syy - (sy * sy) / k;\n  if (vx <= 0 || vy <= 0) return null;\n  return cov / Math.sqrt(vx * vy);\n}\nfunction signAgreement(x, y, deadband = 1e-12) {\n  const n = Math.min(x.length, y.length);\n  let ok = 0, k = 0;\n  for (let i = 0; i < n; i++) {\n    const xi = x[i], yi = y[i];\n    if (!Number.isFinite(xi) || !Number.isFinite(yi)) continue;\n    const sx = Math.abs(xi) <= deadband ? 0 : Math.sign(xi);\n    const sy = Math.abs(yi) <= deadband ? 0 : Math.sign(yi);\n    if (sx === 0 || sy === 0) continue;\n    ok += (sx === sy) ? 1 : 0;\n    k++;\n  }\n  return k ? ok / k : null;\n}\nfunction tailAlign(a, b, maxLen) {\n  const L = Math.min(a.length, b.length, maxLen);\n  return { a: a.slice(a.length - L), b: b.slice(b.length - L), used: L };\n}\nfunction scoreTrend(refD, candD, { wShape, wMag, wDir }) {\n  const { a: r, b: c, used } = tailAlign(refD, candD, MAX_STEPS);\n  const corr = pearsonCorr(r, c);\n  const shape = (corr === null) ? null : (corr + 1) / 2;\n\n  const rMed = median(r.filter(Number.isFinite).map(v => Math.abs(v))) ?? 0;\n  const cMed = median(c.filter(Number.isFinite).map(v => Math.abs(v))) ?? 0;\n  const scale = 0.5 * (rMed + cMed) + 1e-12;\n\n  const e = mae(r, c);\n  const mag = (e === null) ? null : (scale / (scale + e));\n  const dir = signAgreement(r, c);\n\n  const parts = [\n    { v: shape, w: wShape },\n    { v: mag,   w: wMag   },\n    { v: dir,   w: wDir   },\n  ].filter(p => p.v !== null);\n\n  if (!parts.length) return { score: null, used, corr, mae: e, dirAgree: dir };\n  const wsum = parts.reduce((s,p)=>s+p.w,0);\n  const score = parts.reduce((s,p)=>s+p.w*p.v,0) / wsum;\n  return { score, used, corr, mae: e, dirAgree: dir };\n}\nfunction scoreLevel(refL, candL, { wShape, wMag }) {\n  const { a: r, b: c, used } = tailAlign(refL, candL, MAX_STEPS + 1);\n  const corr = pearsonCorr(r, c);\n  const shape = (corr === null) ? null : (corr + 1) / 2;\n\n  const rMed = median(r.filter(Number.isFinite).map(v => Math.abs(v))) ?? 0;\n  const cMed = median(c.filter(Number.isFinite).map(v => Math.abs(v))) ?? 0;\n  const scale = 0.5 * (rMed + cMed) + 1e-12;\n\n  const e = mae(r, c);\n  const mag = (e === null) ? null : (scale / (scale + e));\n\n  const parts = [\n    { v: shape, w: wShape },\n    { v: mag,   w: wMag   },\n  ].filter(p => p.v !== null);\n\n  if (!parts.length) return { score: null, used, corr, mae: e };\n  const wsum = parts.reduce((s,p)=>s+p.w,0);\n  const score = parts.reduce((s,p)=>s+p.w*p.v,0) / wsum;\n  return { score, used, corr, mae: e };\n}\nfunction blend(trendScore, levelScore) {\n  if (trendScore === null && levelScore === null) return null;\n  if (trendScore === null) return levelScore;\n  if (levelScore === null) return trendScore;\n  return TREND_LEVEL_BLEND.trend * trendScore + TREND_LEVEL_BLEND.level * levelScore;\n}\nfunction clamp01(x) { return x === null ? null : Math.max(0, Math.min(1, x)); }\nfunction pct(x) { const v = clamp01(x); return v === null ? null : Math.round(100 * v); }\n\nfunction sortDiffSteps(arr) {\n  return [...arr].sort((A, B) => {\n    const dtA = parseMaybeJson(A['delta t']);\n    const dtB = parseMaybeJson(B['delta t']);\n    const oldA = Array.isArray(dtA) ? toNum(dtA[0]) : null;\n    const oldB = Array.isArray(dtB) ? toNum(dtB[0]) : null;\n    if (oldA !== null && oldB !== null) return oldB - oldA;\n    return 0;\n  });\n}\n\nfunction scoreDtSteps(refDtNewSteps, candDtNewSteps) {\n  const { a: r, b: c, used } = tailAlign(refDtNewSteps, candDtNewSteps, MAX_STEPS);\n  let k = 0, s = 0, maxAbs = 0, sumAbs = 0;\n  for (let i = 0; i < used; i++) {\n    const ri = r[i], ci = c[i];\n    if (!Number.isFinite(ri) || !Number.isFinite(ci)) continue;\n    const d = Math.abs(ri - ci);\n    if (d > maxAbs) maxAbs = d;\n    sumAbs += d;\n    k++;\n    if (d > DT_HARD_DAYS) {\n      return { score: 0, used: k, maxAbsDiff: d, maeAbsDiff: sumAbs / k };\n    }\n    const x = 1 - (d / DT_HARD_DAYS);\n    s += x * x;\n  }\n  if (!k) return { score: null, used: 0, maxAbsDiff: null, maeAbsDiff: null };\n  return { score: s / k, used: k, maxAbsDiff: maxAbs, maeAbsDiff: sumAbs / k };\n}\n\nfunction weightedMean(parts) {\n  const ok = parts.filter(p => p.s !== null);\n  const wsum = ok.reduce((a,p)=>a+p.w,0);\n  return wsum ? ok.reduce((a,p)=>a+p.w*p.s,0)/wsum : null;\n}\n\nfunction pickSeriesMassKg(diffRows) {\n  const m = diffRows.map(r => toNum(r.mass)).filter(Number.isFinite);\n  return m.length ? median(m) : null;\n}\n\n// ===== NEW: pick pair names (mode), fallback to top-2 overall =====\nfunction normName(s) {\n  if (s === null || s === undefined) return null;\n  const t = String(s).trim();\n  if (!t) return null;\n  return t.toUpperCase();\n}\nfunction modeString(arr) {\n  const map = new Map(); // norm -> {count, sample}\n  for (const v of arr) {\n    const n = normName(v);\n    if (!n) continue;\n    if (!map.has(n)) map.set(n, { count: 0, sample: String(v).trim() });\n    map.get(n).count++;\n  }\n  let best = null;\n  for (const [n, obj] of map.entries()) {\n    if (!best || obj.count > best.count) best = { norm: n, count: obj.count, sample: obj.sample };\n  }\n  return best ? best.sample : null;\n}\nfunction pickSeriesPairNames(diffRows) {\n  const aVals = diffRows.map(r => r.pair_a).filter(v => v !== null && v !== undefined && String(v).trim() !== '');\n  const bVals = diffRows.map(r => r.pair_b).filter(v => v !== null && v !== undefined && String(v).trim() !== '');\n\n  let a = modeString(aVals);\n  let b = modeString(bVals);\n\n  // если вдруг a==b или пусто — фолбэк: взять 2 самых частых имени среди (pair_a + pair_b)\n  if (!a || !b || normName(a) === normName(b)) {\n    const all = [...aVals, ...bVals];\n    const map = new Map(); // norm -> {count, sample}\n    for (const v of all) {\n      const n = normName(v);\n      if (!n) continue;\n      if (!map.has(n)) map.set(n, { count: 0, sample: String(v).trim() });\n      map.get(n).count++;\n    }\n    const top = [...map.entries()]\n      .map(([norm, obj]) => ({ norm, count: obj.count, sample: obj.sample }))\n      .sort((x,y) => y.count - x.count);\n\n    a = top[0]?.sample ?? a ?? null;\n    // второй берём с другим norm\n    b = (top.find(x => x.norm !== normName(a))?.sample) ?? b ?? null;\n  }\n\n  return { pair_a_name: a ?? null, pair_b_name: b ?? null };\n}\n\n// Build vectors + traces from DIFF rows\nfunction buildPack(diffRows) {\n  const steps = sortDiffSteps(diffRows);\n\n  const mass_kg = pickSeriesMassKg(diffRows);\n  const { pair_a_name, pair_b_name } = pickSeriesPairNames(diffRows);\n\n  const pcTrend = [];\n  const missTrendPct = [];\n  const rsTrendPct = [];\n\n  const pcLevel = [];\n  const missLevel = [];\n  const rsLevel = [];\n  const dtPoints = [];\n\n  const dtNewSteps = [];\n\n  const covRssTrend = [];\n  const covMaxTrend = [];\n  const covTraceTrend = [];\n\n  const covRssLevel = [];\n  const covMaxLevel = [];\n  const covTraceLevel = [];\n\n  const traceSteps = [];\n\n  for (let i = 0; i < steps.length; i++) {\n    const r = steps[i];\n    const oldV = parseMaybeJson(r.old_values) ?? {};\n    const newV = parseMaybeJson(r.new_values) ?? {};\n    const dPct = parseMaybeJson(r.delta_ptc) ?? {};\n    const dAbs = parseMaybeJson(r.delta) ?? {};\n    const dt = parseMaybeJson(r['delta t']);\n\n    const oldCov = oldV.cov ?? {};\n    const newCov = newV.cov ?? {};\n    const dCovAbs = (dAbs.cov ?? {});\n    const dCovPct = (dPct.cov ?? {});\n\n    const oldPcL = log10Safe(oldV.pc);\n    const newPcL = log10Safe(newV.pc);\n    pcTrend.push((oldPcL !== null && newPcL !== null) ? (newPcL - oldPcL) : null);\n\n    missTrendPct.push(toNum(dPct.miss_distance));\n    rsTrendPct.push(toNum(dPct.rel_speed));\n\n    if (i === 0) {\n      pcLevel.push(log10Safe(oldV.pc));\n      missLevel.push(log1pSafe(oldV.miss_distance));\n      rsLevel.push(toNum(oldV.rel_speed));\n      if (Array.isArray(dt)) dtPoints.push(toNum(dt[0]));\n\n      covRssLevel.push(log1pSafe(oldCov.sigma_rss_1s_m));\n      covMaxLevel.push(log1pSafe(oldCov.sigma_max_1s_m));\n      covTraceLevel.push(log1pSafe(oldCov.cov_total_trace_m2));\n    }\n\n    pcLevel.push(log10Safe(newV.pc));\n    missLevel.push(log1pSafe(newV.miss_distance));\n    rsLevel.push(toNum(newV.rel_speed));\n    if (Array.isArray(dt)) dtPoints.push(toNum(dt[1]));\n\n    if (Array.isArray(dt)) dtNewSteps.push(toNum(dt[1])); else dtNewSteps.push(null);\n\n    covRssLevel.push(log1pSafe(newCov.sigma_rss_1s_m));\n    covMaxLevel.push(log1pSafe(newCov.sigma_max_1s_m));\n    covTraceLevel.push(log1pSafe(newCov.cov_total_trace_m2));\n\n    const oldRssL = log1pSafe(oldCov.sigma_rss_1s_m);\n    const newRssL = log1pSafe(newCov.sigma_rss_1s_m);\n    covRssTrend.push((oldRssL !== null && newRssL !== null) ? (newRssL - oldRssL) : null);\n\n    const oldMaxL = log1pSafe(oldCov.sigma_max_1s_m);\n    const newMaxL = log1pSafe(newCov.sigma_max_1s_m);\n    covMaxTrend.push((oldMaxL !== null && newMaxL !== null) ? (newMaxL - oldMaxL) : null);\n\n    const oldTrL = log1pSafe(oldCov.cov_total_trace_m2);\n    const newTrL = log1pSafe(newCov.cov_total_trace_m2);\n    covTraceTrend.push((oldTrL !== null && newTrL !== null) ? (newTrL - oldTrL) : null);\n\n    traceSteps.push({\n      step_n: i + 1,\n      from_cdm_id: r.from_cdm_id ?? null,\n      to_cdm_id: r.to_cdm_id ?? null,\n      freshness: r['Freshness '] ?? r.Freshness ?? null,\n\n      dt_old_days: Array.isArray(dt) ? toNum(dt[0]) : null,\n      dt_new_days: Array.isArray(dt) ? toNum(dt[1]) : null,\n\n      old: {\n        pc: toNum(oldV.pc),\n        rel_speed: toNum(oldV.rel_speed),\n        miss_distance: toNum(oldV.miss_distance),\n\n        cov_sigma_rss_1s_m: toNum(oldCov.sigma_rss_1s_m),\n        cov_sigma_max_1s_m: toNum(oldCov.sigma_max_1s_m),\n        cov_total_trace_m2: toNum(oldCov.cov_total_trace_m2),\n      },\n      new: {\n        pc: toNum(newV.pc),\n        rel_speed: toNum(newV.rel_speed),\n        miss_distance: toNum(newV.miss_distance),\n\n        cov_sigma_rss_1s_m: toNum(newCov.sigma_rss_1s_m),\n        cov_sigma_max_1s_m: toNum(newCov.sigma_max_1s_m),\n        cov_total_trace_m2: toNum(newCov.cov_total_trace_m2),\n      },\n      delta_abs: {\n        pc: toNum(dAbs.pc),\n        rel_speed: toNum(dAbs.rel_speed),\n        miss_distance: toNum(dAbs.miss_distance),\n\n        cov_sigma_rss_1s_m: toNum((dCovAbs.sigma_rss_1s_m)),\n        cov_sigma_max_1s_m: toNum((dCovAbs.sigma_max_1s_m)),\n        cov_total_trace_m2: toNum((dCovAbs.cov_total_trace_m2)),\n      },\n      delta_pct: {\n        pc: toNum(dPct.pc),\n        rel_speed: toNum(dPct.rel_speed),\n        miss_distance: toNum(dPct.miss_distance),\n\n        cov_sigma_rss_1s_m: toNum((dCovPct.sigma_rss_1s_m)),\n        cov_sigma_max_1s_m: toNum((dCovPct.sigma_max_1s_m)),\n        cov_total_trace_m2: toNum((dCovPct.cov_total_trace_m2)),\n      }\n    });\n  }\n\n  const tracePoints = [];\n  for (let i = 0; i < pcLevel.length; i++) {\n    tracePoints.push({\n      point_n: i + 1,\n      dt_days: dtPoints[i] ?? null,\n      pc: pcLevel[i] === null ? null : Math.pow(10, pcLevel[i]),\n      pc_log10: pcLevel[i],\n      miss_distance: missLevel[i] === null ? null : (Math.expm1(missLevel[i])),\n      miss_log1p: missLevel[i],\n      rel_speed: rsLevel[i] ?? null,\n\n      cov_sigma_rss_1s_m: covRssLevel[i] === null ? null : Math.expm1(covRssLevel[i]),\n      cov_rss_log1p: covRssLevel[i],\n      cov_sigma_max_1s_m: covMaxLevel[i] === null ? null : Math.expm1(covMaxLevel[i]),\n      cov_max_log1p: covMaxLevel[i],\n      cov_total_trace_m2: covTraceLevel[i] === null ? null : Math.expm1(covTraceLevel[i]),\n      cov_trace_log1p: covTraceLevel[i],\n    });\n  }\n\n  return {\n    mass_kg,\n    pair_a_name,\n    pair_b_name,\n\n    steps_count: steps.length,\n    pcTrend, missTrendPct, rsTrendPct,\n    pcLevel, missLevel, rsLevel,\n\n    dtNewSteps,\n    covRssTrend, covMaxTrend, covTraceTrend,\n    covRssLevel, covMaxLevel, covTraceLevel,\n\n    traceSteps,\n    tracePoints\n  };\n}\n\n// ===== MAIN =====\nconst rows = $input.all().map(i => i.json);\n\nconst byKey = new Map();\nfor (const r of rows) {\n  const pk = String(r.pair_key ?? '');\n  if (!pk) continue;\n  if (!byKey.has(pk)) byKey.set(pk, []);\n  byKey.get(pk).push(r);\n}\n\nlet refKey = null;\nfor (const [pk, arr] of byKey.entries()) {\n  if (arr.some(x => Boolean(x.is_ref))) { refKey = pk; break; }\n}\nif (!refKey) throw new Error('No reference series found (is_ref=true).');\n\nconst refPack = buildPack(byKey.get(refKey));\n\nconst results = [];\nfor (const [pk, arr] of byKey.entries()) {\n  if (pk === refKey) continue;\n\n  const candPack = buildPack(arr);\n  const minSteps = Math.min(refPack.steps_count, candPack.steps_count);\n  if (minSteps < 2) {\n    results.push({\n      candidate_pair_key: pk,\n      reference_pair_key: refKey,\n\n      reference_pair_a: refPack.pair_a_name ?? null,\n      reference_pair_b: refPack.pair_b_name ?? null,\n      candidate_pair_a: candPack.pair_a_name ?? null,\n      candidate_pair_b: candPack.pair_b_name ?? null,\n\n      overall_similarity_pct: null,\n      overall_similarity_with_cov_dt_pct: null,\n      note: `Too few DIFF steps (minSteps=${minSteps}).`\n    });\n    continue;\n  }\n\n  const pcTrendS = scoreTrend(refPack.pcTrend, candPack.pcTrend, SHAPE_MAG_DIR);\n  const pcLevelS = scoreLevel(refPack.pcLevel, candPack.pcLevel, SHAPE_MAG);\n  const pcFinal = blend(pcTrendS.score, pcLevelS.score);\n\n  const missTrendS = scoreTrend(refPack.missTrendPct, candPack.missTrendPct, SHAPE_MAG_DIR);\n  const missLevelS = scoreLevel(refPack.missLevel, candPack.missLevel, SHAPE_MAG);\n  const missFinal = blend(missTrendS.score, missLevelS.score);\n\n  const rsTrendS = scoreTrend(refPack.rsTrendPct, candPack.rsTrendPct, SHAPE_MAG_DIR);\n  const rsLevelS = scoreLevel(refPack.rsLevel, candPack.rsLevel, SHAPE_MAG);\n  const rsFinal = blend(rsTrendS.score, rsLevelS.score);\n\n  const overall = weightedMean([\n    { s: pcFinal,   w: SECTION_WEIGHTS.pc },\n    { s: missFinal, w: SECTION_WEIGHTS.miss },\n    { s: rsFinal,   w: SECTION_WEIGHTS.relSpeed },\n  ]);\n\n  const covRssTrendS = scoreTrend(refPack.covRssTrend, candPack.covRssTrend, SHAPE_MAG_DIR);\n  const covRssLevelS = scoreLevel(refPack.covRssLevel, candPack.covRssLevel, SHAPE_MAG);\n  const covRssFinal = blend(covRssTrendS.score, covRssLevelS.score);\n\n  const covMaxTrendS = scoreTrend(refPack.covMaxTrend, candPack.covMaxTrend, SHAPE_MAG_DIR);\n  const covMaxLevelS = scoreLevel(refPack.covMaxLevel, candPack.covMaxLevel, SHAPE_MAG);\n  const covMaxFinal = blend(covMaxTrendS.score, covMaxLevelS.score);\n\n  const covTraceTrendS = scoreTrend(refPack.covTraceTrend, candPack.covTraceTrend, SHAPE_MAG_DIR);\n  const covTraceLevelS = scoreLevel(refPack.covTraceLevel, candPack.covTraceLevel, SHAPE_MAG);\n  const covTraceFinal = blend(covTraceTrendS.score, covTraceLevelS.score);\n\n  const covFinal = weightedMean([\n    { s: covRssFinal,   w: COV_COMPONENT_WEIGHTS.rss },\n    { s: covMaxFinal,   w: COV_COMPONENT_WEIGHTS.max },\n    { s: covTraceFinal, w: COV_COMPONENT_WEIGHTS.trace },\n  ]);\n\n  const dtS = scoreDtSteps(refPack.dtNewSteps, candPack.dtNewSteps);\n  const dtFinal = dtS.score;\n\n  const overallV2 = weightedMean([\n    { s: pcFinal,   w: SECTION_WEIGHTS_V2.pc },\n    { s: missFinal, w: SECTION_WEIGHTS_V2.miss },\n    { s: rsFinal,   w: SECTION_WEIGHTS_V2.relSpeed },\n    { s: covFinal,  w: SECTION_WEIGHTS_V2.cov },\n    { s: dtFinal,   w: SECTION_WEIGHTS_V2.dt },\n  ]);\n\n  const refMass = refPack.mass_kg;\n  const candMass = candPack.mass_kg;\n  const massDeltaKg = (Number.isFinite(refMass) && Number.isFinite(candMass)) ? (candMass - refMass) : null;\n  const massDeltaPct = (Number.isFinite(refMass) && Number.isFinite(candMass) && refMass !== 0)\n    ? (100 * (candMass - refMass) / refMass)\n    : null;\n\n  results.push({\n    candidate_pair_key: pk,\n    reference_pair_key: refKey,\n\n    // NEW: names\n    reference_pair_a: refPack.pair_a_name ?? null,\n    reference_pair_b: refPack.pair_b_name ?? null,\n    candidate_pair_a: candPack.pair_a_name ?? null,\n    candidate_pair_b: candPack.pair_b_name ?? null,\n\n    // mass\n    reference_mass_kg: refMass,\n    candidate_mass_kg: candMass,\n    mass_delta_kg: massDeltaKg,\n    mass_delta_pct: massDeltaPct === null ? null : Math.round(massDeltaPct * 100) / 100,\n\n    overall_similarity_pct: pct(overall),\n    overall_similarity_with_cov_dt_pct: pct(overallV2),\n\n    pc_similarity_pct: pct(pcFinal),\n    miss_similarity_pct: pct(missFinal),\n    rel_speed_similarity_pct: pct(rsFinal),\n\n    cov_similarity_pct: pct(covFinal),\n    dt_similarity_pct: pct(dtFinal),\n\n    trace_steps: candPack.traceSteps.slice(-TRACE_MAX_STEPS),\n    trace_points: candPack.tracePoints.slice(-(TRACE_MAX_STEPS + 1)),\n\n    reference_trace_steps: INCLUDE_REF_TRACE ? refPack.traceSteps.slice(-TRACE_MAX_STEPS) : undefined,\n    reference_trace_points: INCLUDE_REF_TRACE ? refPack.tracePoints.slice(-(TRACE_MAX_STEPS + 1)) : undefined,\n\n    debug: {\n      steps_ref: refPack.steps_count,\n      steps_cand: candPack.steps_count,\n      mass_ref_kg: refMass,\n      mass_cand_kg: candMass,\n      names_ref: { pair_a: refPack.pair_a_name, pair_b: refPack.pair_b_name },\n      names_cand: { pair_a: candPack.pair_a_name, pair_b: candPack.pair_b_name },\n      dt: dtS,\n    }\n  });\n}\n\nresults.sort((a,b) => (b.overall_similarity_pct ?? -1) - (a.overall_similarity_pct ?? -1));\nreturn results.map(r => ({ json: r }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        192
      ],
      "id": "686f3e3d-3bf7-480c-81fe-a831467b742b",
      "name": "Code in JavaScript"
    }
  ],
  "pinData": {},
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Execute a SQL query1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query1": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "ae286273-b89e-4057-9bb2-aa56a8333535",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "b4ea4ca9c3070f4ac2566f1d5b9e37f48c892a17b88ab52397ad078af0d98bdb"
  },
  "id": "hguT2Sryruopkn1x",
  "tags": []
}